<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Google Drive "Shared with me" Downloader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" async defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js" async defer></script>
    <script type="importmap">
    {
      "imports": {
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react": "https://esm.sh/react@18.2.0"
      }
    }
    </script>
  </head>
  <body class="bg-gray-100 dark:bg-gray-900">
    <div id="root"></div>
    <script type="module">
import React from 'react';
import ReactDOM from 'react-dom/client';

// --- START OF APPLICATION CODE ---

// === CONSTANTS ===
// IMPORTANT: Replace with your own credentials from Google Cloud Console
const CLIENT_ID = '50535089451-8gq0jnu98ud11eqpl1moop5o5nbs0t8s.apps.googleusercontent.com';
const SCOPES = 'https://www.googleapis.com/auth/drive.readonly';

const GOOGLE_DOCS_MIMETYPES = {
    'application/vnd.google-apps.document': { exportMimeType: 'application/pdf', extension: '.pdf' },
    'application/vnd.google-apps.spreadsheet': { exportMimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', extension: '.xlsx' },
    'application/vnd.google-apps.presentation': { exportMimeType: 'application/vnd.openxmlformats-officedocument.presentationml.presentation', extension: '.pptx' },
    'application/vnd.google-apps.drawing': { exportMimeType: 'image/png', extension: '.png' },
    'application/vnd.google-apps.form': { exportMimeType: 'application/zip', extension: '.zip' },
    'application/vnd.google-apps.sites': { exportMimeType: 'application/zip', extension: '.zip' },
};

// === ICONS (React Components) ===
const FolderIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { d: "M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" }));
const FileIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm5 1a1 1 0 00-1 1v1a1 1 0 102 0V6a1 1 0 00-1-1z", clipRule: "evenodd" }));
const GoogleDocIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M4 2a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2V4a2 2 0 00-2-2H4zm1 5a1 1 0 000 2h10a1 1 0 100-2H5zm0 4a1 1 0 100 2h10a1 1 0 100-2H5zm0 4a1 1 0 100 2h4a1 1 0 100-2H5z", clipRule: "evenodd" }));
const GoogleSheetIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M4 2a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2V4a2 2 0 00-2-2H4zm8 3a1 1 0 00-2 0v2H8a1 1 0 100 2h2v2a1 1 0 102 0V9h2a1 1 0 100-2h-2V5zM6 7a1 1 0 011-1h2a1 1 0 110 2H7a1 1 0 01-1-1zm1 4a1 1 0 100 2h6a1 1 0 100-2H7z", clipRule: "evenodd" }));
const GoogleSlidesIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M4 2a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2V4a2 2 0 00-2-2H4zm4 4a1 1 0 011-1h6a1 1 0 110 2H9a1 1 0 01-1-1zm-1 5a1 1 0 100 2h6a1 1 0 100-2H7z", clipRule: "evenodd" }));
const DownloadIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }));
const LoadingSpinner = ({ className }) => React.createElement('svg', { className: `animate-spin ${className}`, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, React.createElement('circle', { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), React.createElement('path', { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }));
const SortIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { d: "M3 3a1 1 0 000 2h14a1 1 0 100-2H3zm0 6a1 1 0 000 2h14a1 1 0 100-2H3zm0 6a1 1 0 000 2h14a1 1 0 100-2H3z" }));
const CheckIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", clipRule: "evenodd" }));
const BackArrowIcon = ({ className }) => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z", clipRule: "evenodd" }));

const GetIconForMimeType = ({ mimeType, className = "w-5 h-5" }) => {
    if (mimeType.startsWith('application/vnd.google-apps.folder')) {
        return React.createElement(FolderIcon, { className: `${className} text-blue-500` });
    }
    if (mimeType.startsWith('application/vnd.google-apps.document')) {
        return React.createElement(GoogleDocIcon, { className: `${className} text-blue-600` });
    }
    if (mimeType.startsWith('application/vnd.google-apps.spreadsheet')) {
        return React.createElement(GoogleSheetIcon, { className: `${className} text-green-600` });
    }
    if (mimeType.startsWith('application/vnd.google-apps.presentation')) {
        return React.createElement(GoogleSlidesIcon, { className: `${className} text-yellow-500` });
    }
    return React.createElement(FileIcon, { className: `${className} text-gray-500` });
};

// === HELPER FUNCTIONS ===
const formatBytes = (bytes, decimals = 2) => {
  if (!bytes || bytes === 0) return '0 Bytes';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// === UI COMPONENTS ===
const ZipProgressModal = ({ message }) => {
    return React.createElement('div', { 
        className: "fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50" 
      },
      React.createElement('div', { 
        className: "bg-white dark:bg-gray-800 rounded-lg p-8 shadow-xl flex flex-col items-center" 
      },
        React.createElement(LoadingSpinner, { className: "w-12 h-12 text-blue-500 mb-6" }),
        React.createElement('p', { className: "text-lg font-medium text-gray-800 dark:text-gray-200" }, "Creating Your Download..."),
        React.createElement('p', { className: "text-sm text-gray-600 dark:text-gray-400 mt-2 text-center max-w-xs" }, message)
      )
    );
};

// === MAIN APP COMPONENT ===
const App = () => {
  const { useState, useEffect, useCallback, useMemo, useRef } = React;
  
  const [user, setUser] = useState(null);
  const [files, setFiles] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [breadcrumbs, setBreadcrumbs] = useState([{ id: 'root', name: 'Shared with me' }]);
  const [selectedFiles, setSelectedFiles] = useState(new Set());
  const [folderSizes, setFolderSizes] = useState({});
  const [calculatingFolders, setCalculatingFolders] = useState(new Set());
  const [folderSizeQueue, setFolderSizeQueue] = useState([]);
  const [folderSizeErrors, setFolderSizeErrors] = useState({});
  const [sortKey, setSortKey] = useState('modifiedTime'); // 'name', 'modifiedTime', 'size'
  const [sortOrder, setSortOrder] = useState('desc'); // 'asc', 'desc'
  const [isSortMenuOpen, setIsSortMenuOpen] = useState(false);
  const [isZipping, setIsZipping] = useState(false);
  const [zipProgressMessage, setZipProgressMessage] = useState('');
  const sortMenuRef = useRef(null);

  const currentFolderId = useMemo(() => breadcrumbs[breadcrumbs.length - 1].id, [breadcrumbs]);

  const fetchFiles = useCallback(async (folderId) => {
    setIsLoading(true);
    setError(null);
    try {
      let q = `'${folderId}' in parents and trashed = false`;
      if (folderId === 'root') {
        q = 'sharedWithMe and trashed = false';
      }
      
      const response = await window.gapi.client.drive.files.list({
        q,
        pageSize: 200,
        fields: 'files(id, name, mimeType, modifiedTime, size, iconLink, parents)',
      });
      setFiles(response.result.files || []);
    } catch (err) {
      setError(`Error fetching files: ${err.result?.error?.message || err.message}`);
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const calculateFolderSize = useCallback(async (folderId) => {
    setCalculatingFolders(prev => new Set(prev).add(folderId));
    let totalSize = 0;
    const stack = [folderId];
    try {
      while (stack.length > 0) {
        const currentId = stack.pop();
        const response = await window.gapi.client.drive.files.list({
          q: `'${currentId}' in parents and trashed = false`,
          fields: 'files(id, name, mimeType, size)',
        });
        for (const file of response.result.files) {
          if (file.mimeType === 'application/vnd.google-apps.folder') {
            stack.push(file.id);
          } else if (file.size) {
            totalSize += parseInt(file.size, 10);
          }
        }
      }
      setFolderSizes(prev => ({ ...prev, [folderId]: totalSize }));
    } catch (err) {
      console.error(`Failed to calculate folder size for ${folderId}:`, err);
      setFolderSizeErrors(prev => ({ ...prev, [folderId]: true }));
    } finally {
      setCalculatingFolders(prev => {
        const newSet = new Set(prev);
        newSet.delete(folderId);
        return newSet;
      });
    }
  }, []);
  
  // Effect to queue up folder size calculations
  useEffect(() => {
    if (files.length > 0) {
      const foldersToCalc = files
        .filter(f => f.mimeType === 'application/vnd.google-apps.folder' && folderSizes[f.id] === undefined && !calculatingFolders.has(f.id) && !folderSizeErrors[f.id])
        .map(f => f.id);
      
      if (foldersToCalc.length > 0) {
        setFolderSizeQueue(prevQueue => {
          const newIds = foldersToCalc.filter(id => !prevQueue.includes(id));
          return [...prevQueue, ...newIds];
        });
      }
    }
  }, [files, folderSizes, calculatingFolders, folderSizeErrors]);
  
  // Effect to process the folder size calculation queue
  useEffect(() => {
    if (calculatingFolders.size === 0 && folderSizeQueue.length > 0) {
      const nextFolderId = folderSizeQueue[0];
      setFolderSizeQueue(prevQueue => prevQueue.slice(1));
      calculateFolderSize(nextFolderId);
    }
  }, [folderSizeQueue, calculatingFolders, calculateFolderSize]);

  useEffect(() => {
    const checkGapiAndGis = setInterval(() => {
        if (window.gapi && window.gapi.load && window.google && window.google.accounts) {
            clearInterval(checkGapiAndGis);
            
            window.tokenClient = window.google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: (tokenResponse) => {
                    if (tokenResponse && tokenResponse.access_token) {
                        window.gapi.auth.setToken(tokenResponse);
                        fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                            headers: { 'Authorization': `Bearer ${tokenResponse.access_token}` }
                        })
                        .then(res => res.json())
                        .then(data => {
                            setUser({ name: data.name, email: data.email, picture: data.picture });
                            fetchFiles('root');
                        });
                    }
                },
            });

            window.gapi.load('client', () => {
                window.gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                }).catch((err) => {
                    setError(`API Client Init Error: ${err.message}`);
                });
            });
        }
    }, 100);

    return () => clearInterval(checkGapiAndGis);
  }, [fetchFiles]);
  
   // Effect to handle clicking outside the sort menu
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (sortMenuRef.current && !sortMenuRef.current.contains(event.target)) {
                setIsSortMenuOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

  const handleAuthClick = () => {
    if (user) {
      window.gapi.auth.setToken(null);
      setUser(null);
      setFiles([]);
      setBreadcrumbs([{ id: 'root', name: 'Shared with me' }]);
    } else {
      window.tokenClient.requestAccessToken({ prompt: 'consent' });
    }
  };

  const handleFileClick = (file) => {
    if (file.mimeType === 'application/vnd.google-apps.folder') {
      setBreadcrumbs([...breadcrumbs, { id: file.id, name: file.name }]);
      setFolderSizeQueue([]); // Clear queue for new directory
      fetchFiles(file.id);
    }
  };

  const handleBreadcrumbClick = (index) => {
    const newBreadcrumbs = breadcrumbs.slice(0, index + 1);
    setBreadcrumbs(newBreadcrumbs);
    setFolderSizeQueue([]); // Clear queue for new directory
    fetchFiles(newBreadcrumbs[newBreadcrumbs.length - 1].id);
  };

  const handleGoBack = () => {
    if (breadcrumbs.length > 1) {
      handleBreadcrumbClick(breadcrumbs.length - 2);
    }
  };

  const toggleFileSelection = (fileId) => {
    const newSelection = new Set(selectedFiles);
    if (newSelection.has(fileId)) {
      newSelection.delete(fileId);
    } else {
      newSelection.add(fileId);
    }
    setSelectedFiles(newSelection);
  };
  
  const sortedFiles = useMemo(() => {
    return [...files].sort((a, b) => {
        const isAFolder = a.mimeType === 'application/vnd.google-apps.folder';
        const isBFolder = b.mimeType === 'application/vnd.google-apps.folder';

        if (isAFolder && !isBFolder) return -1;
        if (!isAFolder && isBFolder) return 1;

        let compareA, compareB;

        switch (sortKey) {
            case 'name':
                compareA = a.name.toLowerCase();
                compareB = b.name.toLowerCase();
                break;
            case 'size':
                const aSize = isAFolder ? (folderSizes[a.id] ?? -1) : (parseInt(a.size, 10) || 0);
                const bSize = isBFolder ? (folderSizes[b.id] ?? -1) : (parseInt(b.size, 10) || 0);
                compareA = aSize;
                compareB = bSize;
                break;
            case 'modifiedTime':
            default:
                compareA = new Date(a.modifiedTime).getTime();
                compareB = new Date(b.modifiedTime).getTime();
                break;
        }

        if (compareA < compareB) return sortOrder === 'asc' ? -1 : 1;
        if (compareA > compareB) return sortOrder === 'asc' ? 1 : -1;
        return 0;
    });
  }, [files, sortKey, sortOrder, folderSizes]);
  
  const toggleSelectAll = () => {
    if (selectedFiles.size === sortedFiles.length) {
      setSelectedFiles(new Set());
    } else {
      setSelectedFiles(new Set(sortedFiles.map(f => f.id)));
    }
  };
  
  const downloadFile = async (file) => {
    try {
      let request;
      let fileName = file.name;
      const isGoogleDoc = Object.keys(GOOGLE_DOCS_MIMETYPES).includes(file.mimeType);

      if (isGoogleDoc) {
        const { exportMimeType, extension } = GOOGLE_DOCS_MIMETYPES[file.mimeType];
        fileName += extension;
        request = window.gapi.client.drive.files.export({ fileId: file.id, mimeType: exportMimeType });
      } else {
        request = window.gapi.client.drive.files.get({ fileId: file.id, alt: 'media' });
      }

      const response = await request;
      const blob = new Blob([response.body], { type: response.headers['Content-Type'] });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      a.remove();
    } catch (err) {
      setError(`Error downloading ${file.name}: ${err.result?.error?.message || err.message}`);
      console.error(err);
    }
  };
  
    // --- ZIP and Download Logic ---

    const addFileToZip = async (zipOrZipFolder, file) => {
        try {
            let request;
            let fileName = file.name;
            const isGoogleDoc = Object.keys(GOOGLE_DOCS_MIMETYPES).includes(file.mimeType);

            if (isGoogleDoc) {
                const { exportMimeType, extension } = GOOGLE_DOCS_MIMETYPES[file.mimeType];
                fileName += extension;
                request = window.gapi.client.drive.files.export({ fileId: file.id, mimeType: exportMimeType });
            } else {
                request = window.gapi.client.drive.files.get({ fileId: file.id, alt: 'media' });
            }

            const response = await request;
            zipOrZipFolder.file(fileName, response.body, { binary: true });
        } catch (err) {
            console.error(`Error downloading ${file.name} for zipping:`, err);
            zipOrZipFolder.file(`ERROR_downloading_${file.name}.txt`, `Could not download this file. Error: ${err.result?.error?.message || err.message}`);
        }
    };

    const addFolderToZipRecursive = async (zipFolder, folderId) => {
        try {
            const response = await window.gapi.client.drive.files.list({
                q: `'${folderId}' in parents and trashed = false`,
                pageSize: 500,
                fields: 'files(id, name, mimeType)',
            });

            for (const file of response.result.files) {
                if (file.mimeType === 'application/vnd.google-apps.folder') {
                    setZipProgressMessage(`Scanning: ${file.name}`);
                    const subFolderZip = zipFolder.folder(file.name);
                    await addFolderToZipRecursive(subFolderZip, file.id);
                } else {
                    setZipProgressMessage(`Adding: ${file.name}`);
                    await addFileToZip(zipFolder, file);
                }
                await new Promise(resolve => setTimeout(resolve, 50)); // Small delay to prevent API limits
            }
        } catch (err) {
            console.error(`Could not list files in folder ${folderId}`, err);
            zipFolder.file(`ERROR_listing_folder_contents.txt`, `Could not list contents of this folder. Error: ${err.message}`);
        }
    };

    const downloadSelected = async () => {
        const filesToDownload = sortedFiles.filter(f => selectedFiles.has(f.id));
        const containsFolder = filesToDownload.some(f => f.mimeType === 'application/vnd.google-apps.folder');

        if (filesToDownload.length === 1 && !containsFolder) {
            await downloadFile(filesToDownload[0]);
            return;
        }

        if (!window.JSZip || !window.saveAs) {
            setError("Zipping library is not loaded yet. Please try again in a moment.");
            return;
        }

        setIsZipping(true);
        setZipProgressMessage('Initializing...');
        const zip = new window.JSZip();

        try {
            for (const file of filesToDownload) {
                if (file.mimeType === 'application/vnd.google-apps.folder') {
                    const folderZip = zip.folder(file.name);
                    await addFolderToZipRecursive(folderZip, file.id);
                } else {
                    await addFileToZip(zip, file);
                }
            }

            setZipProgressMessage('Compressing files... this may take a while.');
            const content = await zip.generateAsync({ type: 'blob' }, (metadata) => {
                setZipProgressMessage(`Compressing: ${metadata.percent.toFixed(0)}%`);
            });

            window.saveAs(content, `drive-download-${new Date().toISOString().slice(0, 10)}.zip`);
        } catch (err) {
            setError(`Error creating zip file: ${err.message}`);
            console.error(err);
        } finally {
            setIsZipping(false);
            setZipProgressMessage('');
        }
    };

  const handleDownloadSource = () => {
    const sourceHtml = `<!DOCTYPE html>\n${document.documentElement.outerHTML}`;
    const blob = new Blob([sourceHtml], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'index.html';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  
  const handleSortChange = (key) => {
    if (sortKey === key) {
        setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');
    } else {
        setSortKey(key);
        setSortOrder('desc'); // Default to descending for new column
    }
  };

  const renderHeader = () => React.createElement('header', { className: "bg-white dark:bg-gray-800 shadow-md p-4 flex justify-between items-center sticky top-0 z-10" },
    React.createElement('h1', { className: "text-xl font-bold text-gray-700 dark:text-gray-200" }, "Shared Drive Downloader"),
    React.createElement('div', null,
      user ? React.createElement('div', { className: "flex items-center space-x-4" },
        React.createElement('span', { className: "text-sm text-gray-600 dark:text-gray-300" }, user.name),
        React.createElement('img', { src: user.picture, alt: "User", className: "w-8 h-8 rounded-full" }),
        React.createElement('button', { onClick: handleAuthClick, className: "px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" }, "Sign Out")
      ) : React.createElement('button', { onClick: handleAuthClick, className: "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" }, "Sign In with Google")
    )
  );

  const renderBreadcrumbs = () => React.createElement('nav', { "aria-label": "breadcrumb", className: "flex items-center text-sm" },
    breadcrumbs.map((crumb, index) =>
      React.createElement('div', { key: crumb.id, className: "flex items-center" },
        React.createElement('button', { onClick: () => handleBreadcrumbClick(index), className: "text-gray-500 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400" }, crumb.name),
        index < breadcrumbs.length - 1 && React.createElement('span', { className: "mx-2 text-gray-400" }, "/")
      )
    )
  );

  const renderSortMenu = () => {
    const sortOptions = {
        'DIRECTION': {
            'asc': 'Ascending',
            'desc': 'Descending'
        },
        'SORT BY': {
            'name': 'Name',
            'modifiedTime': 'Last modified',
            'size': 'Size',
        }
    };
    return React.createElement('div', { ref: sortMenuRef, className: "relative" },
        React.createElement('button', {
            onClick: () => setIsSortMenuOpen(prev => !prev),
            className: "p-2 rounded-md text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        }, React.createElement(SortIcon, { className: "w-5 h-5" })),
        isSortMenuOpen && React.createElement('div', {
            className: "origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none z-20"
        }, React.createElement('div', { className: "py-1" },
            Object.entries(sortOptions).map(([section, options]) =>
                React.createElement(React.Fragment, { key: section },
                    React.createElement('div', { className: "px-4 py-2 text-xs font-semibold text-gray-400 uppercase" }, section),
                    Object.entries(options).map(([key, label]) => {
                        const isDirection = section === 'DIRECTION';
                        const isActive = isDirection ? sortOrder === key : sortKey === key;
                        const handleClick = () => {
                            if (isDirection) setSortOrder(key);
                            else setSortKey(key);
                            setIsSortMenuOpen(false);
                        };
                        return React.createElement('button', {
                            key: key,
                            onClick: handleClick,
                            className: `w-full text-left px-4 py-2 text-sm flex justify-between items-center ${isActive ? 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white' : 'text-gray-700 dark:text-gray-300'} hover:bg-gray-100 dark:hover:bg-gray-700`
                        }, label, isActive && React.createElement(CheckIcon, { className: 'w-4 h-4' }))
                    }),
                    section === 'DIRECTION' && React.createElement('div', { className: "border-t border-gray-200 dark:border-gray-700 my-1" })
                )
            )
        ))
    );
  };
  
  const renderSortableHeader = (key, label) => {
    const isActive = sortKey === key;
    return React.createElement('th', { scope: "col", className: "px-6 py-3 text-left text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider" },
        React.createElement('button', {
            onClick: () => handleSortChange(key),
            className: "flex items-center space-x-1 group"
        },
            React.createElement('span', null, label),
            React.createElement('span', { className: `transition-opacity ${isActive ? 'opacity-100' : 'opacity-0 group-hover:opacity-50'}` }, sortOrder === 'asc' ? '↑' : '↓')
        )
    );
  };

  const renderTable = () => React.createElement('div', { className: "overflow-x-auto" },
    React.createElement('table', { className: "min-w-full divide-y divide-gray-200 dark:divide-gray-700" },
      React.createElement('thead', { className: "bg-gray-50 dark:bg-gray-800" },
        React.createElement('tr', null,
          React.createElement('th', { scope: "col", className: "p-4" }, 
            React.createElement('input', { type: "checkbox", onChange: toggleSelectAll, checked: sortedFiles.length > 0 && selectedFiles.size === sortedFiles.length, className: "h-4 w-4 rounded border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 text-blue-600 focus:ring-blue-500 dark:focus:ring-blue-600" })
          ),
          renderSortableHeader('name', 'Name'),
          renderSortableHeader('modifiedTime', 'Last Modified'),
          renderSortableHeader('size', 'Size'),
          React.createElement('th', { scope: "col", className: "relative px-6 py-3" }, React.createElement('span', { className: "sr-only" }, "Download Action"))
        )
      ),
      React.createElement('tbody', { className: "bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700" },
        isLoading ? React.createElement('tr', null, React.createElement('td', { colSpan: 5, className: "text-center p-10" }, React.createElement(LoadingSpinner, { className: "w-10 h-10 text-blue-500 mx-auto" }))) :
        error ? React.createElement('tr', null, React.createElement('td', { colSpan: 5, className: "text-center p-10 text-red-500 font-medium" }, error)) :
        sortedFiles.length === 0 ? React.createElement('tr', null, React.createElement('td', { colSpan: 5, className: "text-center p-10 text-gray-500" }, "This folder is empty.")) :
        sortedFiles.map(file => {
          const isFolder = file.mimeType === 'application/vnd.google-apps.folder';
          const isGoogleDoc = Object.keys(GOOGLE_DOCS_MIMETYPES).includes(file.mimeType);
          
          return React.createElement('tr', { key: file.id, className: "hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors duration-150" },
            React.createElement('td', { className: "p-4" }, 
              React.createElement('input', { type: "checkbox", checked: selectedFiles.has(file.id), onChange: () => toggleFileSelection(file.id), className: "h-4 w-4 rounded border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 text-blue-600 focus:ring-blue-500 dark:focus:ring-blue-600" })
            ),
            React.createElement('td', { className: "px-6 py-4 whitespace-nowrap" }, 
                React.createElement('div', { className: "flex items-center" },
                    React.createElement(GetIconForMimeType, { mimeType: file.mimeType, className: "w-6 h-6 mr-4 flex-shrink-0" }),
                    React.createElement('button', { onClick: () => isFolder && handleFileClick(file), className: `text-sm font-medium text-gray-900 dark:text-gray-100 text-left ${isFolder ? 'hover:underline focus:outline-none' : 'cursor-default'}` }, file.name)
                )
            ),
            React.createElement('td', { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400" }, new Date(file.modifiedTime).toLocaleDateString()),
            React.createElement('td', { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400" },
                isFolder ? 
                    (() => {
                        if (folderSizes[file.id] !== undefined) {
                            return formatBytes(folderSizes[file.id]);
                        }
                        if (folderSizeErrors[file.id]) {
                            return React.createElement('span', { className: 'text-xs text-red-500' }, 'Error');
                        }
                        if (calculatingFolders.has(file.id) || folderSizeQueue.includes(file.id)) {
                            return React.createElement('div', { className: "flex items-center text-xs text-gray-500 dark:text-gray-400" },
                                React.createElement(LoadingSpinner, { className: "w-4 h-4 inline mr-2" }),
                                calculatingFolders.has(file.id) ? "Calculating..." : "Queued"
                            );
                        }
                        return '---'; // Fallback for folders not yet queued.
                    })() : 
                    (file.size ? formatBytes(parseInt(file.size, 10)) : (isGoogleDoc ? 'Google Doc' : '---'))
            ),
            React.createElement('td', { className: "px-6 py-4 whitespace-nowrap text-right text-sm font-medium" },
                !isFolder && React.createElement('button', { onClick: () => downloadFile(file), title: `Download ${file.name}`, className: "p-2 rounded-full text-gray-500 hover:text-gray-800 hover:bg-gray-200 dark:text-gray-400 dark:hover:text-gray-100 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" },
                    React.createElement(DownloadIcon, { className: "w-5 h-5" })
                )
            )
          );
        })
      )
    )
  );

  return React.createElement('div', { className: "min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 font-sans flex flex-col" },
    isZipping && React.createElement(ZipProgressModal, { message: zipProgressMessage }),
    renderHeader(),
    React.createElement('main', { className: "p-4 md:p-8 flex-grow" },
      !user ?
        React.createElement('div', { className: "text-center p-16 bg-white dark:bg-gray-800 rounded-lg shadow" },
          React.createElement('h2', { className: "text-2xl font-semibold mb-4" }, "Welcome!"),
          React.createElement('p', { className: "text-gray-600 dark:text-gray-300" }, "Please sign in with your Google account to view your shared files.")
        ) :
        React.createElement('div', { className: "bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden" },
          React.createElement('div', { className: "p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center" },
            React.createElement('div', { className: "flex-grow flex items-center" },
              breadcrumbs.length > 1 && React.createElement('button', { 
                  onClick: handleGoBack,
                  className: "mr-2 p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors",
                  title: "Go back"
              }, React.createElement(BackArrowIcon, { className: "w-5 h-5" })),
              renderBreadcrumbs()
            ),
            React.createElement('div', { className: "flex items-center space-x-2" },
              selectedFiles.size > 0 && React.createElement('button', { 
                onClick: downloadSelected, 
                disabled: isZipping,
                className: "flex items-center px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:bg-gray-400 disabled:cursor-not-allowed" 
              },
                React.createElement(DownloadIcon, { className: "w-4 h-4 mr-2" }),
                `Download (${selectedFiles.size})`
              ),
              renderSortMenu()
            )
          ),
          renderTable()
        )
    ),
    React.createElement('footer', { className: 'p-4 text-center text-xs text-gray-500 dark:text-gray-400' },
      React.createElement('p', null, 'Google Drive "Shared with me" Downloader'),
      React.createElement('button', { 
        onClick: handleDownloadSource, 
        className: 'mt-1 text-blue-500 hover:underline'
      }, 'Download Source Code (index.html)')
    )
  );
};

// === RENDER THE APP ===
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(React.createElement(App));

// --- END OF APPLICATION CODE ---
    </script>
  </body>
</html>
